---
title: Tutorial - Create an Azure virtual machine scale set from a Packer custom image by using Terraform
description: Use Terraform to configure and version an Azure virtual machine scale set from a custom image generated by Packer (complete with a virtual network and managed attached disks).
ms.topic: tutorial
ms.date: 11/07/2019
---

# Tutorial: Create an Azure virtual machine scale set from a Packer custom image by using Terraform

In this tutorial, you use [Terraform](https://www.terraform.io/) to create and deploy an [Azure virtual machine scale set](/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-overview) created with a custom image produced by using [Packer](https://www.packer.io/intro/index.html) with managed disks that use the [HashiCorp Configuration Language](https://www.terraform.io/docs/configuration/syntax.html) (HCL). 

In this tutorial, you learn how to:

> [!div class="checklist"]
> * Set up your Terraform deployment.
> * Use variables and outputs for Terraform deployment.
> * Create and deploy a network infrastructure.
> * Create a custom virtual machine image by using Packer.
> * Create and deploy a virtual machine scale set by using the custom image.
> * Create and deploy a jumpbox.

If you don't have an Azure subscription, create a [free account](https://azure.microsoft.com/free/?WT.mc_id=A261C142F) before you begin.

## Prerequisites

- **Terraform**: [Install Terraform and configure access to Azure](/azure/virtual-machines/linux/terraform-install-configure).
- **SSH key pair**: [Create an SSH key pair](/azure/virtual-machines/linux/mac-create-ssh-keys).
- **Packer**:  [Install Packer](https://www.packer.io/docs/install/index.html).

## Create the file structure

Create three new files in an empty directory with the following names:

- `variables.tf`: This file holds the values of the variables used in the template.
- `output.tf`: This file describes the settings that display after deployment.
- `vmss.tf`: This file contains the code of the infrastructure that you're deploying.

##  Create the variables 

In this step, you define variables that customize the resources created by Terraform.

Edit the `variables.tf` file, copy the following code, and then save the changes.

```hcl
variable "location" {
  description = "The location where resources are created"
  default     = "East US"
}

variable "resource_group_name" {
  description = "The name of the resource group in which the resources are created"
  default     = ""
}

```

> [!NOTE]
> The default value of the resource_group_name variable is unset. Define your own value.

Save the file.

When you deploy your Terraform template, you want to get the fully qualified domain name that's used to access the application. Use the `output` resource type of Terraform, and get the `fqdn` property of the resource. 

Edit the `output.tf` file, and copy the following code to expose the fully qualified domain name for the virtual machines. 

```hcl 
output "vmss_public_ip" {
    value = azurerm_public_ip.vmss.fqdn
}
```

## Define the network infrastructure in a template 

In this step, you create the following network infrastructure in a new Azure resource group: 
  - One virtual network with the address space of 10.0.0.0/16.
  - One subnet with the address space of 10.0.2.0/24.
  - Two public IP addresses. One is used by the virtual machine scale set load balancer. The other is used to connect to the SSH jumpbox.

You also need a resource group where all the resources are created. 

Edit and copy the following code in the `vmss.tf` file: 

```hcl

resource "azurerm_resource_group" "vmss" {
  name     = var.resource_group_name
  location = var.location

  tags {
    environment = "codelab"
  }
}

resource "azurerm_virtual_network" "vmss" {
  name                = "vmss-vnet"
  address_space       = ["10.0.0.0/16"]
  location            = var.location
  resource_group_name = azurerm_resource_group.vmss.name

  tags {
    environment = "codelab"
  }
}

resource "azurerm_subnet" "vmss" {
  name                 = "vmss-subnet"
  resource_group_name  = azurerm_resource_group.vmss.name
  virtual_network_name = azurerm_virtual_network.vmss.name
  address_prefix       = "10.0.2.0/24"
}

resource "azurerm_public_ip" "vmss" {
  name                         = "vmss-public-ip"
  location                     = var.location
  resource_group_name          = azurerm_resource_group.vmss.name
  allocation_method            = "static"
  domain_name_label            = azurerm_resource_group.vmss.name

  tags {
    environment = "codelab"
  }
}

``` 

> [!NOTE]
> Tag the resources that are being deployed in Azure to facilitate their identification in the future.

## Create the network infrastructure

Initialize the Terraform environment by running the following command in the directory where you created the `.tf` files:

```bash
terraform init 
```
 
The provider plug-ins download from the Terraform registry into the `.terraform` folder in the directory where you ran the command.

Run the following command to deploy the infrastructure in Azure.

```bash
terraform apply
```

Verify that the fully qualified domain name of the public IP address corresponds to your configuration.

![Virtual machine scale set Terraform fully qualified domain name for public IP address](./media/terraform-create-vm-scaleset-network-disks-using-packer-hcl/tf-create-vmss-step4-fqdn.png)

The resource group contains the following resources:

![Virtual machine scale set Terraform network resources](./media/terraform-create-vm-scaleset-network-disks-using-packer-hcl/tf-create-vmss-step4-rg.png)


## Create an Azure image by using Packer
Create a custom Linux image by following the steps in the tutorial [How to use Packer to create Linux virtual machine images in Azure](/azure/virtual-machines/linux/build-image-with-packer).
 
Follow the tutorial to create a deprovisioned Ubuntu image with Nginx installed.

![After you create the Packer image, you have an image](./media/terraform-create-vm-scaleset-network-disks-using-packer-hcl/packerimagecreated.png)

> [!NOTE]
> For the purposes of this tutorial, in the Packer image, a command is run to install Nginx. You can also run your own script while creating.

## Edit the infrastructure to add the virtual machine scale set

In this step, you create the following resources on the network that was previously deployed:
- An Azure load balancer to serve the application. Attach it to the public IP address that was deployed earlier.
- One Azure load balancer and rules to serve the application. Attach it to the public IP address that was configured earlier.
- An Azure back-end address pool. Assign it to the load balancer.
- A health probe port used by the application and configured on the load balancer.
- A virtual machine scale set that sits behind the load balancer and runs on the virtual network that was deployed earlier.
- [Nginx](https://nginx.org/) on the nodes of the virtual machine scale installed from a custom image.


Add the following code to the end of the `vmss.tf` file.

```hcl

resource "azurerm_lb" "vmss" {
  name                = "vmss-lb"
  location            = var.location
  resource_group_name = azurerm_resource_group.vmss.name

  frontend_ip_configuration {
    name                 = "PublicIPAddress"
    public_ip_address_id = azurerm_public_ip.vmss.id
  }

  tags {
    environment = "codelab"
  }
}

resource "azurerm_lb_backend_address_pool" "bpepool" {
  resource_group_name = azurerm_resource_group.vmss.name
  loadbalancer_id     = azurerm_lb.vmss.id
  name                = "BackEndAddressPool"
}

resource "azurerm_lb_probe" "vmss" {
  resource_group_name = azurerm_resource_group.vmss.name
  loadbalancer_id     = azurerm_lb.vmss.id
  name                = "ssh-running-probe"
  port                = var.application_port
}

resource "azurerm_lb_rule" "lbnatrule" {
  resource_group_name            = azurerm_resource_group.vmss.name
  loadbalancer_id                = azurerm_lb.vmss.id
  name                           = "http"
  protocol                       = "Tcp"
  frontend_port                  = var.application_port
  backend_port                   = var.application_port
  backend_address_pool_id        = azurerm_lb_backend_address_pool.bpepool.id
  frontend_ip_configuration_name = "PublicIPAddress"
  probe_id                       = azurerm_lb_probe.vmss.id
}

data "azurerm_resource_group" "image" {
  name = "myResourceGroup"
}

data "azurerm_image" "image" {
  name                = "myPackerImage"
  resource_group_name = data.azurerm_resource_group.image.name
}

resource "azurerm_virtual_machine_scale_set" "vmss" {
  name                = "vmscaleset"
  location            = var.location
  resource_group_name = azurerm_resource_group.vmss.name
  upgrade_policy_mode = "Manual"

  sku {
    name     = "Standard_DS1_v2"
    tier     = "Standard"
    capacity = 2
  }

  storage_profile_image_reference {
    id=data.azurerm_image.image.id
  }

  storage_profile_os_disk {
    name              = ""
    caching           = "ReadWrite"
    create_option     = "FromImage"
    managed_disk_type = "Standard_LRS"
  }

  storage_profile_data_disk {
    lun          = 0
    caching        = "ReadWrite"
    create_option  = "Empty"
    disk_size_gb   = 10
  }

  os_profile {
    computer_name_prefix = "vmlab"
    admin_username       = "azureuser"
    admin_password       = "Passwword1234"
  }

  os_profile_linux_config {
    disable_password_authentication = true

    ssh_keys {
      path     = "/home/azureuser/.ssh/authorized_keys"
      key_data = file("~/.ssh/id_rsa.pub")
    }
  }

  network_profile {
    name    = "terraformnetworkprofile"
    primary = true

    ip_configuration {
      name                                   = "IPConfiguration"
      subnet_id                              = azurerm_subnet.vmss.id
      load_balancer_backend_address_pool_ids = [azurerm_lb_backend_address_pool.bpepool.id]
      primary = true
    }
  }
  
  tags {
    environment = "codelab"
  }
}

```

Customize the deployment by adding the following code to `variables.tf`:

```hcl
variable "application_port" {
    description = "The port that you want to expose to the external load balancer"
    default     = 80
}

variable "admin_password" {
    description = "Default password for admin"
    default = "Passwwoord11223344"
}
``` 


## Deploy the virtual machine scale set in Azure

Run the following command to visualize the virtual machine scale set deployment:

```bash
terraform plan
```

The output of the command looks like the following image:

![Terraform add virtual machine scale set plan](./media/terraform-create-vm-scaleset-network-disks-using-packer-hcl/tf-create-vmss-step6-plan.png)

Deploy the additional resources in Azure: 

```bash
terraform apply 
```

The content of the resource group looks like the following image:

![Terraform virtual machine scale set resource group](./media/terraform-create-vm-scaleset-network-disks-using-packer-hcl/tf-create-vmss-step6-apply.png)

Open a browser and connect to the fully qualified domain name that was returned by the command. 


## Add a jumpbox to the existing network 

This optional step enables SSH access to the instances of the virtual machine scale set by using a jumpbox.

Add the following resources to your existing deployment:
- A network interface connected to the same subnet as the virtual machine scale set
- A virtual machine with this network interface

Add the following code to the end of the `vmss.tf` file:

```hcl 
resource "azurerm_public_ip" "jumpbox" {
  name                         = "jumpbox-public-ip"
  location                     = var.location
  resource_group_name          = azurerm_resource_group.vmss.name
  allocation_method            = "static"
  domain_name_label            = "${azurerm_resource_group.vmss.name}-ssh"

  tags {
    environment = "codelab"
  }
}

resource "azurerm_network_interface" "jumpbox" {
  name                = "jumpbox-nic"
  location            = var.location
  resource_group_name = azurerm_resource_group.vmss.name

  ip_configuration {
    name                          = "IPConfiguration"
    subnet_id                     = azurerm_subnet.vmss.id
    private_ip_address_allocation = "dynamic"
    public_ip_address_id          = azurerm_public_ip.jumpbox.id
  }

  tags {
    environment = "codelab"
  }
}

resource "azurerm_virtual_machine" "jumpbox" {
  name                  = "jumpbox"
  location              = var.location
  resource_group_name   = azurerm_resource_group.vmss.name
  network_interface_ids = [azurerm_network_interface.jumpbox.id]
  vm_size               = "Standard_DS1_v2"

  storage_image_reference {
    publisher = "Canonical"
    offer     = "UbuntuServer"
    sku       = "16.04-LTS"
    version   = "latest"
  }

  storage_os_disk {
    name              = "jumpbox-osdisk"
    caching           = "ReadWrite"
    create_option     = "FromImage"
    managed_disk_type = "Standard_LRS"
  }

  os_profile {
    computer_name  = "jumpbox"
    admin_username = "azureuser"
    admin_password = "Password1234!"
  }

  os_profile_linux_config {
    disable_password_authentication = true

    ssh_keys {
      path     = "/home/azureuser/.ssh/authorized_keys"
      key_data = file("~/.ssh/id_rsa.pub")
    }
  }

  tags {
    environment = "codelab"
  }
}
```

Edit `outputs.tf` to add the following code that displays the hostname of the jumpbox when the deployment finishes:

```
output "jumpbox_public_ip" {
    value = azurerm_public_ip.jumpbox.fqdn
}
```

## Deploy the jumpbox

Deploy the jumpbox.

```bash
terraform apply 
```

After the deployment has completed, the content of the resource group looks like the following image:

![Terraform virtual machine scale set resource group](./media/terraform-create-vm-scaleset-network-disks-using-packer-hcl/tf-create-create-vmss-step8.png)

> [!NOTE]
> Sign-in with a password is disabled on the jumpbox and the virtual machine scale set that you deployed. Sign in with SSH to access the VMs.

## Clean up the environment

The following commands delete the resources created in this tutorial:

```bash
terraform destroy
```

Enter *yes* when you're asked to confirm the deletion of the resources. The destruction process can take a few minutes to complete.

## Next steps

> [!div class="nextstepaction"] 
> [Learn more about using Terraform in Azure](/azure/terraform)
